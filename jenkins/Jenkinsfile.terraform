/*
 * Jenkinsfile.terraform - Infrastructure Deployment Pipeline
 * 
 * This pipeline manages infrastructure using Terraform.
 * It automatically triggers when .tf files are modified.
 * 
 * Features:
 *   - Multi-environment support (dev, staging, prod)
 *   - Automatic plan generation
 *   - Manual approval for production
 *   - State management with remote backend
 */

pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Target environment for infrastructure deployment'
        )
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'Terraform action to perform'
        )
        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: 'Auto-approve terraform apply (not recommended for prod)'
        )
    }
    
    environment {
        // AWS Configuration (adjust for your cloud provider)
        AWS_REGION = 'eu-west-1'
        AWS_CREDENTIALS = credentials('aws-credentials')
        
        // Terraform Configuration
        TF_IN_AUTOMATION = 'true'
        TF_INPUT = 'false'
        TF_CLI_ARGS = '-no-color'
        
        // State Configuration
        TF_STATE_BUCKET = credentials('terraform-state-bucket')
        
        // Working directory
        TF_WORKING_DIR = "environments/${params.ENVIRONMENT}"
    }
    
    options {
        timeout(time: 60, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '30'))
        disableConcurrentBuilds()
        timestamps()
        ansiColor('xterm')
    }
    
    triggers {
        // Trigger on changes to .tf files (via webhook)
        pollSCM('H/5 * * * *')
    }
    
    stages {
        stage('Checkout Infrastructure Code') {
            steps {
                echo "üì¶ Checking out Terraform repository..."
                git branch: 'main',
                    url: 'https://github.com/Aminamrane/terraform-infrastructure.git',
                    credentialsId: 'github-token'
            }
        }
        
        stage('Check for Terraform Changes') {
            steps {
                script {
                    echo "üîç Checking for Terraform file changes..."
                    
                    // Get list of changed files
                    def changedFiles = sh(
                        script: '''
                            git diff --name-only HEAD~1 HEAD 2>/dev/null || echo ""
                        ''',
                        returnStdout: true
                    ).trim()
                    
                    echo "Changed files:\n${changedFiles}"
                    
                    // Check if any .tf files changed
                    def tfChanged = changedFiles.split('\n').any { it.endsWith('.tf') || it.endsWith('.tfvars') }
                    
                    if (!tfChanged && currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause').isEmpty()) {
                        echo "‚è≠Ô∏è No Terraform files changed, skipping pipeline..."
                        currentBuild.result = 'NOT_BUILT'
                        return
                    }
                    
                    echo "‚úÖ Terraform changes detected, proceeding with pipeline..."
                }
            }
        }
        
        stage('Setup Terraform') {
            steps {
                script {
                    echo "‚öôÔ∏è Setting up Terraform..."
                    
                    sh '''
                        # Check Terraform version
                        terraform version
                        
                        # Verify working directory exists
                        if [ ! -d "${TF_WORKING_DIR}" ]; then
                            echo "‚ùå Environment directory not found: ${TF_WORKING_DIR}"
                            exit 1
                        fi
                        
                        echo "‚úÖ Terraform setup complete"
                    '''
                }
            }
        }
        
        stage('Terraform Init') {
            steps {
                script {
                    echo "üîß Initializing Terraform..."
                    
                    dir("${TF_WORKING_DIR}") {
                        sh '''
                            terraform init \
                                -backend=true \
                                -backend-config="bucket=${TF_STATE_BUCKET}" \
                                -backend-config="key=terraform/${ENVIRONMENT}/terraform.tfstate" \
                                -backend-config="region=${AWS_REGION}" \
                                -reconfigure
                        '''
                    }
                    
                    echo "‚úÖ Terraform initialized successfully"
                }
            }
        }
        
        stage('Terraform Validate') {
            steps {
                script {
                    echo "‚úîÔ∏è Validating Terraform configuration..."
                    
                    dir("${TF_WORKING_DIR}") {
                        sh 'terraform validate'
                    }
                    
                    echo "‚úÖ Terraform configuration is valid"
                }
            }
        }
        
        stage('Terraform Format Check') {
            steps {
                script {
                    echo "üìù Checking Terraform formatting..."
                    
                    dir("${TF_WORKING_DIR}") {
                        def formatCheck = sh(
                            script: 'terraform fmt -check -recursive',
                            returnStatus: true
                        )
                        
                        if (formatCheck != 0) {
                            echo "‚ö†Ô∏è Terraform files are not properly formatted"
                            echo "Run 'terraform fmt -recursive' to fix"
                        } else {
                            echo "‚úÖ Terraform formatting is correct"
                        }
                    }
                }
            }
        }
        
        stage('Terraform Plan') {
            steps {
                script {
                    echo "üìã Generating Terraform plan for ${params.ENVIRONMENT}..."
                    
                    dir("${TF_WORKING_DIR}") {
                        sh '''
                            terraform plan \
                                -var-file="terraform.tfvars" \
                                -out=tfplan \
                                -detailed-exitcode || exit_code=$?
                            
                            # Save plan for later use
                            terraform show -no-color tfplan > tfplan.txt
                            
                            echo "=== TERRAFORM PLAN ==="
                            cat tfplan.txt
                            echo "======================"
                        '''
                    }
                    
                    // Archive the plan for review
                    archiveArtifacts artifacts: "${TF_WORKING_DIR}/tfplan.txt", fingerprint: true
                    
                    echo "‚úÖ Terraform plan generated successfully"
                }
            }
        }
        
        stage('Approval for Production') {
            when {
                allOf {
                    expression { return params.ACTION == 'apply' || params.ACTION == 'destroy' }
                    expression { return params.ENVIRONMENT == 'prod' }
                    expression { return params.AUTO_APPROVE == false }
                }
            }
            steps {
                script {
                    echo "‚è∏Ô∏è Waiting for manual approval for PRODUCTION deployment..."
                    
                    def userInput = input(
                        id: 'prodApproval',
                        message: "Deploy to PRODUCTION?",
                        parameters: [
                            [$class: 'BooleanParameterDefinition',
                             name: 'CONFIRM',
                             defaultValue: false,
                             description: 'Check to confirm production deployment']
                        ],
                        submitterParameter: 'approver'
                    )
                    
                    if (!userInput.CONFIRM) {
                        error "Production deployment was not confirmed"
                    }
                    
                    echo "‚úÖ Production deployment approved by ${userInput.approver}"
                }
            }
        }
        
        stage('Approval for Staging') {
            when {
                allOf {
                    expression { return params.ACTION == 'apply' || params.ACTION == 'destroy' }
                    expression { return params.ENVIRONMENT == 'staging' }
                    expression { return params.AUTO_APPROVE == false }
                }
            }
            steps {
                script {
                    timeout(time: 30, unit: 'MINUTES') {
                        input message: "Deploy to STAGING environment?", ok: "Deploy"
                    }
                    echo "‚úÖ Staging deployment approved"
                }
            }
        }
        
        stage('Terraform Apply') {
            when {
                expression { return params.ACTION == 'apply' }
            }
            steps {
                script {
                    echo "üöÄ Applying Terraform changes to ${params.ENVIRONMENT}..."
                    
                    dir("${TF_WORKING_DIR}") {
                        sh 'terraform apply -auto-approve tfplan'
                    }
                    
                    echo "‚úÖ Infrastructure deployed successfully!"
                }
            }
        }
        
        stage('Terraform Destroy') {
            when {
                expression { return params.ACTION == 'destroy' }
            }
            steps {
                script {
                    echo "‚ö†Ô∏è DESTROYING infrastructure in ${params.ENVIRONMENT}..."
                    
                    dir("${TF_WORKING_DIR}") {
                        sh 'terraform destroy -auto-approve -var-file="terraform.tfvars"'
                    }
                    
                    echo "‚úÖ Infrastructure destroyed"
                }
            }
        }
        
        stage('Output Infrastructure Details') {
            when {
                expression { return params.ACTION == 'apply' }
            }
            steps {
                script {
                    echo "üìä Infrastructure outputs:"
                    
                    dir("${TF_WORKING_DIR}") {
                        sh 'terraform output -json > outputs.json || true'
                        sh 'terraform output || true'
                    }
                    
                    // Archive outputs
                    archiveArtifacts artifacts: "${TF_WORKING_DIR}/outputs.json", fingerprint: true, allowEmptyArchive: true
                }
            }
        }
        
        stage('Trigger Helm Deployment') {
            when {
                allOf {
                    expression { return params.ACTION == 'apply' }
                    expression { return currentBuild.result == null || currentBuild.result == 'SUCCESS' }
                }
            }
            steps {
                script {
                    echo "üîÑ Triggering Helm deployment for updated infrastructure..."
                    
                    // Trigger Helm pipeline to deploy applications
                    build job: 'helm-deploy',
                        parameters: [
                            string(name: 'SERVICE', value: 'all'),
                            string(name: 'IMAGE_TAG', value: 'latest'),
                            string(name: 'ENVIRONMENT', value: params.ENVIRONMENT)
                        ],
                        wait: false
                    
                    echo "‚úÖ Helm deployment triggered"
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo "‚úÖ Terraform pipeline completed successfully!"
                echo "üèóÔ∏è Environment: ${params.ENVIRONMENT}"
                echo "üìã Action: ${params.ACTION}"
                
                // slackSend(color: 'good', message: "Terraform ${params.ACTION} on ${params.ENVIRONMENT} succeeded")
            }
        }
        failure {
            script {
                echo "‚ùå Terraform pipeline failed!"
                echo "üîç Check the logs above for details"
                
                // slackSend(color: 'danger', message: "Terraform ${params.ACTION} on ${params.ENVIRONMENT} FAILED")
            }
        }
        always {
            echo "üßπ Cleaning up workspace..."
            cleanWs()
        }
    }
}

